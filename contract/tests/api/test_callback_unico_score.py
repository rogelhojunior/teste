"""This module implements tests for view callback_unico_score."""
# built-in
import json
import random
import string
from typing import List
from unittest.mock import patch

# thirds
from django.test import Client, TestCase
from django.urls import reverse

from contract.api.views.unico_request_processor import UnicoRequestProcessor
from contract.api.views.unico_score_contract_validator import (
    UNICO_DIVERGENCY_STATUS,
    UNICO_RULE_DESCRIPTION,
    UNICO_SCORE_SUCCESS_STATUS,
)
from contract.constants import EnumContratoStatus, EnumTipoContrato, EnumTipoProduto
from contract.models.contratos import CartaoBeneficio, Contrato, Portabilidade

# local
from contract.models.envelope_contratos import EnvelopeContratos
from contract.models.status_contrato import StatusContrato
from contract.models.validacao_contrato import ValidacaoContrato
from contract.products.cartao_beneficio.constants import ContractStatus
from documentscopy.models import BPOConfig, BPORow, Product
from documentscopy.services import BPOProcessor


class TestCaseCallBackUnicoScore(TestCase):
    """Implements tests for view callback_unico_score."""

    def setUp(self):
        # This method is called before each test case
        self.client = Client()

    def generate_random_string(self, length: int = 10) -> str:
        """Generate a random string with defined length."""
        characters = string.ascii_letters + string.digits
        return ''.join(random.choice(characters) for _ in range(length))

    def create_envelope(self, process_id: str) -> EnvelopeContratos:
        """Create a new EnvelopeContratos record.

        Args:
            process_id (str): the process id registered in the envelope.

        Returns:
            EnvelopeContratos: the envelope created.
        """
        return EnvelopeContratos.objects.create(id_processo_unico=process_id)

    def insert_contracts_inside_envelope(
        self, n: int, envelope: EnvelopeContratos
    ) -> List[Contrato]:
        """
        Create n contracts and insert them into a envelope.

        Args:
            n (int): how many contracts to insert.
            envelope (EnvelopeContratos): witch envelope to insert.

        Returns:
            List[Contratos]: all the contracts created and inserted.
        """
        created_contracts = []
        for _ in range(n):
            contract = self.generate_contract(
                ctype=EnumTipoContrato.PORTABILIDADE,
                envelope=envelope.token_envelope,
            )
            created_contracts.append(contract)

        return created_contracts

    def generate_contract(
        self,
        envelope: str,
        ctype: int = EnumTipoContrato.PORTABILIDADE,
        product: int = EnumTipoProduto.PORTABILIDADE,
    ) -> Contrato:
        """
        Create a new contract.

        Args:
            envelope (EnvelopeContratos): the envelope token.
            ctype (int): the type of the contract.
            product (int): the type of the product.
        """
        return Contrato.objects.create(
            cd_contrato_tipo=ctype, token_envelope=envelope, tipo_produto=product
        )

    def create_payload(self, process_id: str, status: int, score: int = None) -> dict:
        """
        Create a payload to send to the endpoint being tested.

        Args:
            process_id (str): the process id registered in the envelope.
            status (str): the number of the status generated by UNICO.
            score (int): the score generated by UNICO.

        """
        data = {
            'eventDate':'2022-03-08T15:05:19.4530112Z',
            'event':'update_process',
            'data': {
                'id': process_id,
                'status': status,
            }
        }
        if score is not None:
            data['data']['score'] = score
        return data

    @patch.object(UnicoRequestProcessor, 'decode_data')
    def test_approved_scores_signed_contract(self, mocked_decode_data):
        """
        When the received score is success and the contract is
        already signed by the final client, a ValidacaoContrato record
        must be created.
        """

        scores_to_test = [50, 75, 99]

        for score in scores_to_test:
            # create objects
            process_id = self.generate_random_string()
            envelope = self.create_envelope(process_id)
            contracts = self.insert_contracts_inside_envelope(2, envelope)
            sign_envelope_contracts(envelope)


            for contract in contracts:
                # create sub_contract record, of type Portabilidade
                Portabilidade.objects.create(
                    contrato=contract,
                    saldo_devedor=300,
                    prazo=1,
                    parcela_digitada=200,
                    nova_parcela=1,
                )

            # send request
            url = reverse('callback_unico_score')
            data = self.create_payload(
                process_id=process_id, status=UNICO_SCORE_SUCCESS_STATUS, score=score
            )
            mocked_decode_data.return_value = data

            response = self.client.post(url,
                                        data=json.dumps(data),
                                        content_type='application/json')

            # assert response
            self.assertEqual(response.status_code, 200)

            # assert envelope
            envelope.refresh_from_db()
            self.assertEqual(float(envelope.score_unico), score)
            self.assertEqual(envelope.status_unico, UNICO_SCORE_SUCCESS_STATUS)

            # assert contracts
            for contract in contracts:
                validation = ValidacaoContrato.objects.get(contrato=contract)
                self.assertEqual(validation.mensagem_observacao, UNICO_RULE_DESCRIPTION)
                self.assertEqual(
                    validation.retorno_hub,
                    format_validation_message(f'SCORE APROVADO Valor: {score}'),
                )
                self.assertTrue(validation.checked)

    @patch.object(UnicoRequestProcessor, 'decode_data')
    def test_approved_scores_unsigned_contract(self, mocked_decode_data):
        """
        When the received score is success but the contract is not
        already signed by the final client, a ValidacaoContrato record
        must not be created.
        """

        # create objects
        process_id = self.generate_random_string()
        envelope = self.create_envelope(process_id)
        contracts = self.insert_contracts_inside_envelope(2, envelope)

        # send request
        url = reverse('callback_unico_score')
        score = 75
        data = self.create_payload(
            process_id=process_id, status=UNICO_SCORE_SUCCESS_STATUS, score=score
        )
        mocked_decode_data.return_value = data
        response = self.client.post(url,
                                        data=json.dumps(data),
                                        content_type='application/json')

        # assert response
        self.assertEqual(response.status_code, 200)

        # assert envelope
        envelope.refresh_from_db()
        self.assertEqual(float(envelope.score_unico), score)
        self.assertEqual(envelope.status_unico, UNICO_SCORE_SUCCESS_STATUS)

        # assert contracts
        for contract in contracts:
            with self.assertRaises(ValidacaoContrato.DoesNotExist):
                ValidacaoContrato.objects.get(contrato=contract)

    @patch.object(UnicoRequestProcessor, 'decode_data')
    def test_disapproved_scores_benefit_card(self, mocked_decode_data):
        """
        When score is disapproved, if the contract is signed by the
        final client, if tipo produto is CARTAO BENEFICIO, the following
        items actions must be performed:

        1- ValidacaoContrato record must have attribute 'checked' =
            False
        2- ValidacaoContrato record must have attribute 'retorno_hub' =
            'SCORE REPROVADO Valor: <score>'
        3- CartaoBeneficio record must have attribute 'status' =
            ContractStatus.CHECAGEM_MESA_FORMALIZACAO
        4- Contrato record must have attribute 'status' =
            EnumContratoStatus.MESA
        5- A new StatusContrato record must be created with attribute
            'name' = ContractStatus.CHECAGEM_MESA_FORMALIZACAO
        """

        scores_to_test = [-10, 0, 49]

        for score in scores_to_test:
            # create envelope and insert signed contract
            process_id = self.generate_random_string()
            envelope = self.create_envelope(process_id)
            contract = self.generate_contract(
                envelope=envelope.token_envelope,
                product=EnumTipoProduto.CARTAO_BENEFICIO,
            )
            sign_envelope_contracts(envelope)

            # create sub_contract record, of type CartaoBeneficio
            sub_contract = CartaoBeneficio.objects.create(contrato=contract)

            # saving information before execute view
            contract_status_count_before = StatusContrato.objects.count()

            # send request
            url = reverse('callback_unico_score')
            data = self.create_payload(
                process_id=process_id, status=UNICO_SCORE_SUCCESS_STATUS, score=score
            )
            mocked_decode_data.return_value = data
            response = self.client.post(url,
                                        data=json.dumps(data),
                                        content_type='application/json')

            # assert response
            self.assertEqual(response.status_code, 200)

            # assert envelope
            envelope.refresh_from_db()
            self.assertEqual(int(envelope.score_unico), score)
            self.assertEqual(envelope.status_unico, UNICO_SCORE_SUCCESS_STATUS)

            # assert ValidacaoContrato record
            validation = ValidacaoContrato.objects.get(contrato=contract)
            self.assertEqual(validation.mensagem_observacao, UNICO_RULE_DESCRIPTION)
            self.assertEqual(
                validation.retorno_hub,
                format_validation_message(f'SCORE REPROVADO Valor: {score}'),
            )
            self.assertFalse(validation.checked)

            # assert CartaoBeneficio record
            sub_contract.refresh_from_db()
            self.assertEqual(
                sub_contract.status, ContractStatus.CHECAGEM_MESA_FORMALIZACAO.value
            )

            # assert Contrato record
            contract.refresh_from_db()
            self.assertEqual(contract.status, EnumContratoStatus.MESA)

            # assert StatusContrato record
            contract_status_record = contract.last_status
            self.assertEqual(
                contract_status_record.nome,
                ContractStatus.CHECAGEM_MESA_FORMALIZACAO.value,
            )
            contract_status_count_after = StatusContrato.objects.count()
            self.assertEqual(
                contract_status_count_after, contract_status_count_before + 1
            )

    @patch.object(UnicoRequestProcessor, 'decode_data')
    def test_divergency_scores_benefit_card(self, mocked_decode_data):
        """
        Divergency status means that UNICO did not sent a score, so the
        status key come with the value 2 instead of 3. In this scenario
        if the contract is signed by the final client, if tipo produto
        is CARTAO BENEFICIO, the following items actions must be
        performed:

        1- ValidacaoContrato record must have attribute 'checked' =
            False
        2- ValidacaoContrato record must have attribute 'retorno_hub' =
            'SCORE REPROVADO Divergencia na Unico'
        3- CartaoBeneficio record must have attribute 'status' =
            ContractStatus.CHECAGEM_MESA_FORMALIZACAO
        4- Contrato record must have attribute 'status' =
            EnumContratoStatus.MESA
        5- A new StatusContrato record must be created with attribute
            'name' = ContractStatus.CHECAGEM_MESA_FORMALIZACAO
        """
        # create envelope and insert signed contract
        process_id = self.generate_random_string()
        envelope = self.create_envelope(process_id)
        contract = self.generate_contract(
            envelope=envelope.token_envelope, product=EnumTipoProduto.CARTAO_BENEFICIO
        )
        sign_envelope_contracts(envelope)

        # create sub_contract record, of type CartaoBeneficio
        sub_contract = CartaoBeneficio.objects.create(contrato=contract)

        # saving information before execute view
        contract_status_count_before = StatusContrato.objects.count()

        # send request
        url = reverse('callback_unico_score')
        data = self.create_payload(
            process_id=process_id, status=UNICO_DIVERGENCY_STATUS
        )
        mocked_decode_data.return_value = data
        response = self.client.post(url,
                                        data=json.dumps(data),
                                        content_type='application/json')

        # assert response
        self.assertEqual(response.status_code, 200)

        # assert envelope
        envelope.refresh_from_db()
        self.assertIsNone(envelope.score_unico)
        self.assertEqual(envelope.status_unico, UNICO_DIVERGENCY_STATUS)

        # assert ValidacaoContrato record
        validation = ValidacaoContrato.objects.get(contrato=contract)
        self.assertEqual(validation.mensagem_observacao, UNICO_RULE_DESCRIPTION)
        self.assertEqual(
            validation.retorno_hub,
            format_validation_message('SCORE REPROVADO Divergencia na Unico'),
        )
        self.assertFalse(validation.checked)

        # assert CartaoBeneficio record
        sub_contract.refresh_from_db()
        self.assertEqual(
            sub_contract.status, ContractStatus.CHECAGEM_MESA_FORMALIZACAO.value
        )

        # assert Contrato record
        contract.refresh_from_db()
        self.assertEqual(contract.status, EnumContratoStatus.MESA)

        # assert StatusContrato record
        contract_status_record = contract.last_status
        self.assertEqual(
            contract_status_record.nome, ContractStatus.CHECAGEM_MESA_FORMALIZACAO.value
        )
        contract_status_count_after = StatusContrato.objects.count()
        self.assertEqual(contract_status_count_after, contract_status_count_before + 1)

    @patch.object(UnicoRequestProcessor, 'decode_data')
    def test_disapproved_scores_portability(self, mocked_decode_data):
        """
        When score is disapproved, if the contract is signed by the
        final client, if tipo produto is PORTABILIDADE, the following
        items actions must be performed:

        1- ValidacaoContrato record must have attribute 'checked' =
            False
        2- ValidacaoContrato record must have attribute 'retorno_hub' =
            'SCORE REPROVADO Valor: <score>'
        3- Portabilidade record must have attribute 'status' =
            ContractStatus.REPROVADA_POLITICA_INTERNA
        4- Contrato record must have attribute 'status' =
            EnumContratoStatus.CANCELADO
        5- A new StatusContrato record must be created with attribute
            'name' = ContractStatus.REPROVADA_POLITICA_INTERNA and
            attribute 'descricao_mesa' = 'O SCORE na unico foi muito
            baixo por isso a proposta foi cancelada'
        """
        scores_to_test = [-10, 0, 49]

        for score in scores_to_test:
            # create envelope and insert signed contract
            process_id = self.generate_random_string()
            envelope = self.create_envelope(process_id)
            contract = self.generate_contract(
                envelope=envelope.token_envelope, product=EnumTipoProduto.PORTABILIDADE
            )
            sign_envelope_contracts(envelope)

            # create sub_contract record, of type CartaoBeneficio
            sub_contract = Portabilidade.objects.create(
                contrato=contract,
                saldo_devedor=300,
                prazo=1,
                parcela_digitada=200,
                nova_parcela=1,
            )

            # saving information before execute view
            contract_status_count_before = StatusContrato.objects.count()

            # send request
            url = reverse('callback_unico_score')
            data = self.create_payload(
                process_id=process_id, status=UNICO_SCORE_SUCCESS_STATUS, score=score
            )
            mocked_decode_data.return_value = data
            response = self.client.post(url,
                                        data=json.dumps(data),
                                        content_type='application/json')

            # assert response
            self.assertEqual(response.status_code, 200)

            # assert envelope
            envelope.refresh_from_db()
            self.assertEqual(int(envelope.score_unico), score)
            self.assertEqual(envelope.status_unico, UNICO_SCORE_SUCCESS_STATUS)

            # assert ValidacaoContrato record
            validation = ValidacaoContrato.objects.get(contrato=contract)
            self.assertEqual(validation.mensagem_observacao, UNICO_RULE_DESCRIPTION)
            self.assertEqual(
                validation.retorno_hub,
                format_validation_message(f'SCORE REPROVADO Valor: {score}'),
            )
            self.assertFalse(validation.checked)

            # assert CartaoBeneficio record
            sub_contract.refresh_from_db()
            self.assertEqual(
                sub_contract.status, ContractStatus.REPROVADA_POLITICA_INTERNA.value
            )

            # assert Contrato record
            contract.refresh_from_db()
            self.assertEqual(contract.status, EnumContratoStatus.CANCELADO)

            # assert StatusContrato record
            contract_status_record = contract.last_status
            self.assertEqual(
                contract_status_record.nome,
                ContractStatus.REPROVADA_POLITICA_INTERNA.value,
            )
            self.assertEqual(
                contract_status_record.descricao_mesa,
                'Recusada por politíca interna (SF) - Biometria facial',
            )
            contract_status_count_after = StatusContrato.objects.count()
            self.assertEqual(
                contract_status_count_after, contract_status_count_before + 1
            )

    @patch.object(UnicoRequestProcessor, 'decode_data')
    def test_divergency_scores_portability(self, mocked_decode_data):
        """
        Divergency status means that UNICO did not sent a score, so the
        status key come with the value 2 instead of 3. In this scenario
        if the contract is signed by the final client, if tipo produto
        is PORTABILIDADE, the following items actions must be
        performed:

        1- ValidacaoContrato record must have attribute 'checked' =
            False
        2- ValidacaoContrato record must have attribute 'retorno_hub' =
            'SCORE REPROVADO Divergencia na Unico'
        3- Portabilidade record must have attribute 'status' =
            ContractStatus.REPROVADA_POLITICA_INTERNA
        4- Contrato record must have attribute 'status' =
            EnumContratoStatus.CANCELADO
        5- A new StatusContrato record must be created with attribute
            'name' = ContractStatus.REPROVADA_POLITICA_INTERNA and
            'descricao_mesa' = 'O SCORE na unico foi muito baixo por
            isso a proposta foi cancelada'
        """
        # create envelope and insert signed contract
        process_id = self.generate_random_string()
        envelope = self.create_envelope(process_id)
        contract = self.generate_contract(
            envelope=envelope.token_envelope, product=EnumTipoProduto.PORTABILIDADE
        )
        sign_envelope_contracts(envelope)

        # create sub_contract record, of type Portabilidade
        sub_contract = Portabilidade.objects.create(
            contrato=contract,
            saldo_devedor=300,
            prazo=1,
            parcela_digitada=200,
            nova_parcela=1,
        )

        # saving information before execute view
        contract_status_count_before = StatusContrato.objects.count()

        # send request
        url = reverse('callback_unico_score')
        data = self.create_payload(
            process_id=process_id, status=UNICO_DIVERGENCY_STATUS
        )
        mocked_decode_data.return_value = data
        response = self.client.post(url,
                                        data=json.dumps(data),
                                        content_type='application/json')

        # assert response
        self.assertEqual(response.status_code, 200)

        # assert envelope
        envelope.refresh_from_db()
        self.assertIsNone(envelope.score_unico)
        self.assertEqual(envelope.status_unico, UNICO_DIVERGENCY_STATUS)

        # assert ValidacaoContrato record
        validation = ValidacaoContrato.objects.get(contrato=contract)
        self.assertEqual(validation.mensagem_observacao, UNICO_RULE_DESCRIPTION)
        self.assertEqual(
            validation.retorno_hub,
            format_validation_message('SCORE REPROVADO Divergencia na Unico'),
        )
        self.assertFalse(validation.checked)

        # assert CartaoBeneficio record
        sub_contract.refresh_from_db()
        self.assertEqual(
            sub_contract.status, ContractStatus.REPROVADA_POLITICA_INTERNA.value
        )

        # assert Contrato record
        contract.refresh_from_db()
        self.assertEqual(contract.status, EnumContratoStatus.CANCELADO)

        # assert StatusContrato record
        contract_status_record = contract.last_status
        self.assertEqual(
            contract_status_record.nome, ContractStatus.REPROVADA_POLITICA_INTERNA.value
        )
        self.assertEqual(
            contract_status_record.descricao_mesa,
            'Recusada por politíca interna (SF) - Biometria facial',
        )
        contract_status_count_after = StatusContrato.objects.count()
        self.assertEqual(contract_status_count_after, contract_status_count_before + 1)

    def test_new_workflow(self):
        scores_to_test = [50, 75, 99]

        for score in scores_to_test:
            # create objects
            process_id = self.generate_random_string()
            envelope = self.create_envelope(process_id)
            contracts = self.insert_contracts_inside_envelope(2, envelope)
            sign_envelope_contracts(envelope)


            for contract in contracts:
                # create sub_contract record, of type Portabilidade
                Portabilidade.objects.create(
                    contrato=contract,
                    saldo_devedor=300,
                    prazo=1,
                    parcela_digitada=200,
                    nova_parcela=1,
                )

            # send request
            url = reverse('callback_unico_score')
            data = self.create_payload(
                process_id=process_id, status=UNICO_SCORE_SUCCESS_STATUS, score=score
            )

            response = self.client.post(url,
                                        data=json.dumps(data),
                                        content_type='application/json')

            # assert response
            self.assertEqual(response.status_code, 200)

            # assert envelope
            envelope.refresh_from_db()
            self.assertEqual(float(envelope.score_unico), score)
            self.assertEqual(envelope.status_unico, UNICO_SCORE_SUCCESS_STATUS)

            # assert contracts
            for contract in contracts:
                validation = ValidacaoContrato.objects.get(contrato=contract)
                self.assertEqual(validation.mensagem_observacao, UNICO_RULE_DESCRIPTION)
                self.assertEqual(
                    validation.retorno_hub,
                    format_validation_message(f'SCORE APROVADO Valor: {score}'),
                )
                self.assertTrue(validation.checked)

    def test_serasa(self):
        """
        When score is between -90 and -10, if the contract is signed by
        the final client, if tipo produto is PORTABILIDADE, the
        following items actions must be performed:

        1- ValidacaoContrato record must have attribute 'checked' =
            False
        2- ValidacaoContrato record must have attribute 'retorno_hub' =
            'SCORE REPROVADO Valor: <score>'
        3- Portabilidade record must have attribute 'status' =
            ContractStatus.CHECAGEM_MESA_CORBAN
        4- Contrato record must have attribute 'status' =
            EnumContratoStatus.MESA
        5- A new StatusContrato record must be created with attribute
            'name' = ContractStatus.CHECAGEM_MESA_CORBAN and
            'descricao_mesa' = 'SCORE da UNICO abaixo do aceito'
        """


        # create envelope and insert signed contract
        process_id = self.generate_random_string()
        envelope = self.create_envelope(process_id)
        contract = self.generate_contract(
            envelope=envelope.token_envelope, product=EnumTipoProduto.PORTABILIDADE
        )
        sign_envelope_contracts(envelope)
        # create sub_contract record, of type Portabilidade
        sub_contract = Portabilidade.objects.create(
            contrato=contract,
            saldo_devedor=300,
            prazo=1,
            parcela_digitada=200,
            nova_parcela=1,
        )
        StatusContrato.objects.create(
                contrato=contract,
                nome=ContractStatus.FORMALIZACAO_CLIENTE.value,
        )
        bpo = BPOConfig()
        bpo.save()
        bpo.products.set([Product.objects.get(product=EnumTipoProduto.PORTABILIDADE)])
        bpo.save()
        #bpo = BPOConfig.objects.create(
        #    products=[Product.objects.get(product=EnumTipoProduto.PORTABILIDADE)]
        #)

        BPORow.objects.create(
            bpo=0,
            amount_from=100,
            amount_to=500,
            parameter=bpo
        )

        processo = BPOProcessor(contract, sub_contract)

        assert processo.bpo == 0

    def test_restrictive_error_scores_benefit_card(self):
        """
        When score is between -90 and -10, if the contract is signed by
        the final client, if tipo produto is PORTABILIDADE, the
        following items actions must be performed:

        1- ValidacaoContrato record must have attribute 'checked' =
            False
        2- ValidacaoContrato record must have attribute 'retorno_hub' =
            'SCORE REPROVADO Valor: <score>'
        3- Portabilidade record must have attribute 'status' =
            ContractStatus.CHECAGEM_MESA_CORBAN
        4- Contrato record must have attribute 'status' =
            EnumContratoStatus.MESA
        5- A new StatusContrato record must be created with attribute
            'name' = ContractStatus.CHECAGEM_MESA_CORBAN and
            'descricao_mesa' = 'SCORE da UNICO abaixo do aceito'
        """

        scores_to_test = [-90]

        for score in scores_to_test:
            # create envelope and insert signed contract
            process_id = self.generate_random_string()
            envelope = self.create_envelope(process_id)
            contract = self.generate_contract(
                envelope=envelope.token_envelope, product=EnumTipoProduto.PORTABILIDADE
            )
            sign_envelope_contracts(envelope)

            # create sub_contract record, of type Portabilidade
            sub_contract = Portabilidade.objects.create(
                contrato=contract,
                saldo_devedor=300,
                prazo=1,
                parcela_digitada=200,
                nova_parcela=1,
            )

            StatusContrato.objects.create(
                    contrato=contract,
                    nome=ContractStatus.FORMALIZACAO_CLIENTE.value,
            )

            # saving information before execute view
            contract_status_count_before = StatusContrato.objects.count()

            # send request
            url = reverse('callback_unico_score')
            data = self.create_payload(
                process_id=process_id, status=UNICO_SCORE_SUCCESS_STATUS, score=score
            )
            #mocked_decode_data.return_value = data
            response = self.client.post(url,
                                        data=json.dumps(data),
                                        content_type='application/json')

            # assert response
            self.assertEqual(response.status_code, 200)

            # assert envelope
            envelope.refresh_from_db()
            self.assertEqual(int(envelope.score_unico), score)
            self.assertEqual(envelope.status_unico, UNICO_SCORE_SUCCESS_STATUS)

            # assert ValidacaoContrato record
            validation = ValidacaoContrato.objects.get(contrato=contract)
            self.assertEqual(validation.mensagem_observacao, UNICO_RULE_DESCRIPTION)
            self.assertEqual(
                validation.retorno_hub,
                format_validation_message(f'SCORE REPROVADO Valor: {score}'),
            )
            self.assertFalse(validation.checked)

            # assert CartaoBeneficio record
            sub_contract.refresh_from_db()
            self.assertEqual(
                sub_contract.status,
                ContractStatus.CHECAGEM_MESA_CORBAN.value
            )

            # assert Contrato record
            contract.refresh_from_db()
            self.assertEqual(contract.status, EnumContratoStatus.MESA)

            # assert StatusContrato record
            contract_status_record = contract.last_status
            self.assertEqual(
                contract_status_record.nome, ContractStatus.CHECAGEM_MESA_CORBAN.value
            )
            self.assertEqual(
                contract_status_record.descricao_mesa, 'SCORE da UNICO abaixo do aceito'
            )
            contract_status_count_after = StatusContrato.objects.count()
            self.assertEqual(
                contract_status_count_after, contract_status_count_before + 1
            )


def format_validation_message(message: str) -> str:
    """Format a message in the same format than ValidacaoConntrato
    messages."""
    return str((message,))


def sign_envelope_contracts(envelope: EnvelopeContratos) -> None:
    """
    Mark attribute 'contrato_assinado' as True for all contracts
    inside the envelope.

    Args:
        envelope (EnvelopeContratos): the envelope containing contracts.
    """
    for contract in envelope.contracts:
        contract.contrato_assinado = True
        contract.save()


def unsign_envelope_contracts(envelope: EnvelopeContratos) -> None:
    """
    Mark attribute 'contrato_assinado' as False for all contracts
    inside the envelope.

    Args:
        envelope (EnvelopeContratos): the envelope containing contracts.
    """
    for contract in envelope.contracts:
        contract.contrato_assinado = False
        contract.save()
